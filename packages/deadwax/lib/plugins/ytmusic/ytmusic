SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLUGIN_VERSION="0.1.0"

log() {
  :
  # gum log --level info "$@"
}

evolve_id() {
  local string=$1
  local type=""
  local id=""

  if [[ "$string" =~ ^https://music\.youtube\.com/channel/UC || "$string" =~ ^UC[\w-]{22}$ ]]; then
    type="artist"
    id=$(extract_id "$string" '(?<=channel/)UC[\w-]{22}$') || id="$string"
  elif [[ "$string" =~ ^(https://music\.youtube\.com/playlist\?list=)?OLAK5uy_[A-Za-z0-9_-]{33}$ ]]; then
    type="album"
    id=$(extract_id "$string" '(?<=list=)OLAK5uy_[A-Za-z0-9_-]{33}(?=&|$)') || id="$string"
  elif [[ "$string" =~ ^https://music\.youtube\.com/browse/MPREb_ || "$string" =~ ^MPREb_[a-zA-Z0-9_-]+$ ]]; then
    type="album"
    mpreb_album_id=$(extract_id "$string" 'MPREb_[a-zA-Z0-9_-]+') || id="$string"
    id=$(get_album_id_from_mpreb "$mpreb_album_id")
  elif [[ "$string" =~ ^https://music\.youtube\.com/playlist\?list= || "$string" =~ ^PL ]]; then
    type="playlist"
    id=$(extract_id "$string" '(?<=list=)[a-zA-Z0-9_-]+(?=&|$)') || id="$string"
  elif [[ "$string" =~ ^https://music\.youtube\.com/watch\?v= || "$string" =~ ^[a-zA-Z0-9_-]{11}$ ]]; then
    type="song"
    id=$(extract_id "$string" '(?<=v=)[a-zA-Z0-9_-]{11}') || id="$string"
  else
    echo '{ "error": "Invalid id format" }' >&2
    return 1
  fi

  jq -n \
    --arg type "$type" \
    --arg id "$id" '{
      type: $type,
      value: $id,
    }'
}

encodeTagId() {
  case "$1" in
  familiar) echo "iY" ;;
  discover) echo "iX" ;;
  popular) echo "pY" ;;
  deep) echo "pX" ;;
  sleep) echo "mf" ;;
  focus) echo "ma" ;;
  chill) echo "mX" ;;
  electronic) echo "gi" ;;
  pump-up) echo "mY" ;;
  metal) echo "g6X" ;;
  rock) echo "gFX" ;;
  instrumental) echo "nX" ;;
  romance) echo "md" ;;
  jazz) echo "gy" ;;
  *)
    echo "Error: Unsupported Tag" >&2
    return 1
    ;;
  esac
}

buildTaggedPlaylistIdFromSong() {
  local videoId=$1
  local tag=$2

  if [ -z "$videoId" ] || [ -z "$tag" ]; then
    echo "Error: Both videoId and tag are required" >&2
    return 1
  fi

  local id="RD"

  if [ "$tag" = "all" ]; then
    id="${id}AMVM"
  else
    encoded_tag=$(encodeTagId "$tag")
    id="${id}AT${encoded_tag}v"
  fi

  id="${id}${videoId}"

  echo "$id"
}

buildTaggedPlaylistIdFromAlbum() {
  local albumId=$1
  local tag=$2

  if [ -z "$albumId" ] || [ -z "$tag" ]; then
    echo "Error: Both albumId and tag are required" >&2
    return 1
  fi

  local id="RD"

  if [ "$tag" = "all" ]; then
    id="${id}AMPL"
  else
    encoded_tag=$(encodeTagId "$tag")
    id="${id}AT${encoded_tag}b9X"
  fi

  id="${id}${albumId}"

  echo "$id"
}

get_album_id_from_mpreb () {
  local mpreb=$1

  curl \
  'https://music.youtube.com/youtubei/v1/browse?prettyPrint=false' \
  --compressed \
  -X POST \
  -H 'Accept-Encoding: gzip, deflate, br, zstd' \
  -H 'Accept-Language: en-US,en;q=0.5' \
  -H 'Accept: */*' \
  -H 'Alt-Used: music.youtube.com' \
  -H 'Connection: keep-alive' \
  -H 'Content-Type: application/json' \
  -H 'DNT: 1' \
  -H 'Origin: https://music.youtube.com' \
  -H 'Priority: u=0' \
  -H 'Referer: https://music.youtube.com/library' \
  -H 'Sec-Fetch-Dest: empty' \
  -H 'Sec-Fetch-Mode: same-origin' \
  -H 'Sec-Fetch-Site: same-origin' \
  -H 'Sec-GPC: 1' \
  -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:131.0) Gecko/20100101 Firefox/131.0' \
  -H 'X-Goog-AuthUser: 0' \
  -H 'X-Origin: https://music.youtube.com' \
  -H 'X-Youtube-Client-Name: 67' \
  -H 'X-Youtube-Client-Version: 1.20241023.01.00' \
    --data-raw '{
    "browseId": "'"$mpreb"'",
    "context": {
      "client": {
        "hl": "en",
        "gl": "US",
        "remoteHost": "15.0.93.55",
        "deviceMake": "",
        "deviceModel": "",
        "userAgent": "Mozilla/5.0 (X11; Linux x86_64; rv:131.0) Gecko/20100101 Firefox/131.0,gzip(gfe)",
        "clientName": "WEB_REMIX",
        "clientVersion": "1.20241023.01.00",
        "osName": "X11",
        "osVersion": "",
        "originalUrl": "https://music.youtube.com/library",
        "platform": "DESKTOP",
        "clientFormFactor": "UNKNOWN_FORM_FACTOR",
        "configInfo": { },
        "userInterfaceTheme": "USER_INTERFACE_THEME_DARK",
        "timeZone": "America/Chicago",
        "browserName": "Firefox",
        "browserVersion": "131.0",
        "acceptHeader": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/png,image/svg+xml,*/*;q=0.8",
      },
      "activePlayers": []
    }
  }' |
  jq --raw-output '
    .contents
    .twoColumnBrowseResultsRenderer
    .secondaryContents
    .sectionListRenderer
    .contents[0]
    .musicShelfRenderer
    .contents[0]
    .musicResponsiveListItemRenderer
    .overlay
    .musicItemThumbnailOverlayRenderer
    .content
    .musicPlayButtonRenderer
    .playNavigationEndpoint
    .watchEndpoint
    .playlistId
  '
}

getRawJsonPlaylist() {
  local extraJson=$1

  # Placeholder function for album handling
  log info "Processing.."

  curl \
    'https://music.youtube.com/youtubei/v1/next?prettyPrint=false' \
    --compressed \
    -X POST \
    -H 'Accept-Encoding: gzip, deflate, br, zstd' \
    -H 'Accept-Language: en-US,en;q=0.5' \
    -H 'Accept: */*' \
    -H 'Connection: keep-alive' \
    -H 'Content-Type: application/json' \
    -H 'DNT: 1' \
    -H 'Origin: https://music.youtube.com' \
    -H 'Priority: u=0' \
    -H 'Sec-Fetch-Dest: empty' \
    -H 'Sec-Fetch-Mode: same-origin' \
    -H 'Sec-Fetch-Site: same-origin' \
    -H 'Sec-GPC: 1' \
    -H 'TE: trailers' \
    -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:131.0) Gecko/20100101 Firefox/131.0' \
    -H 'X-Youtube-Bootstrap-Logged-In: false' \
    -H 'X-Youtube-Client-Name: 67' \
    -H 'X-Youtube-Client-Version: 1.20241016.01.00' \
    --data-raw "$(
      jq -s '.[0] * .[1]' "${SCRIPT_DIR}/data.json" <(echo "$extraJson")
    )"
}

# TODO: To support tags, you must first grab the "all" playlist (as we are now), then parse the special ablum id for tags found here:
# "contents.singleColumnMusicWatchNextResultsRenderer.tabbedRenderer.watchNextTabbedResultsRenderer.tabs.0.tabRenderer.content.musicQueueRenderer.subHeaderChipCloud.chipCloudRenderer.chips[X].chipCloudChipRenderer.navigationEndpoint.queueUpdateCommand.fetchContentsCommand.watchEndpoint.playlistId"
# ex: RDATpYa04qmrEz
# a is likley the separator, so the rest would be the id
getPlaylistFromArtist() {
  local channel_id="$1"
  local channel_data

  log info "Fetching artist data for $channel_id"
  channel_data=$(curl -s 'https://music.youtube.com/channel/'"$channel_id" \
    --compressed \
    -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:131.0) Gecko/20100101 Firefox/131.0')

  log debug "Channel data length: ${#channel_data} characters"

  if [[ "$DEBUG" == true ]]; then
    echo "$channel_data" >debug_channel_data.txt
    log debug "Channel data saved to debug_channel_data.txt"
  fi

  local playlist_id
  # local video_id

  # video_id="$(
  #   echo "$channel_data" |
  #     grep -oP '(?<=\\x22videoId\\x22:\\x22)[^\\x22]*(?=\\x22)' |
  #     head -n 1
  # )"
  playlist_id="$(
    echo "$channel_data" |
      grep -oP '(?<=\\x22playlistId\\x22:\\x22)RDEM\w+-\w+' |
      head -n 1
  )"

  log debug "Extracted playlist ID: ${playlist_id:-<empty>}"
  # log debug "Extracted video ID: ${video_id:-<empty>}"

  if [[ -z "$playlist_id" ]]; then
    log error "Failed to extract playlist or video ID"
    log error "Please check the channel URL and try again"
    log error "If the problem persists, run with --debug and check debug_channel_data.txt"
    exit 1
  fi

  log debug "${video_id} ${playlist_id}"

  local url
  url="https://music.youtube.com/watch?list=${playlist_id}"

  log debug "$url"

  getRawJsonPlaylist '{
    "playlistId": "'"$playlist_id"'"
  }' |
    jq -r '{
      playlist_name: "YouTube Music",
      encoding: "UTF-8",
      tracks: [
        .contents
        .singleColumnMusicWatchNextResultsRenderer
        .tabbedRenderer
        .watchNextTabbedResultsRenderer
        .tabs[0]
        .tabRenderer
        .content
        .musicQueueRenderer
        .content
        .playlistPanelRenderer
        .contents[] |
          select(.playlistPanelVideoRenderer != null) | .playlistPanelVideoRenderer | {
            title: .title.runs[0].text,
            artist: .longBylineText.runs[0].text,
            album: (.longBylineText.runs[2].text // "Unknown"),
            duration: ((.lengthText.runs[0].text | split(":") | map(tonumber) | .[0] * 60 + .[1]) | tostring),
            year: (.longBylineText.runs[4].text // "Unknown"),
            genre: "Unknown",
            thumbnail: .thumbnail.thumbnails[-1].url,
            video_id: .videoId,
            url: "https://www.youtube.com/watch?v=\(.videoId)"
          }
      ]
    }'
}

extract_id() {
  local url="$1"
  local pattern="$2"
  echo "$url" | grep -oP "$pattern"
}

direct() {
  local obj="$1"
  local type
  local id
  local response

  eval "$(jq -r '@sh "
    type=\(.id.type)
    id=\(.id.value)
    tag=\(.args.tag)
  "' <<<"$obj")"

  case "$type" in
  "album")
    response="$(
      getRawJsonPlaylist '{
        "playlistId": "'"$id"'"
      }' |
      jq -r '
        .contents.singleColumnMusicWatchNextResultsRenderer
          .tabbedRenderer.watchNextTabbedResultsRenderer
          .tabs[0].tabRenderer.content
          .musicQueueRenderer.header
          .musicQueueHeaderRenderer.subtitle
          .runs[0].text as $album |

        .contents.singleColumnMusicWatchNextResultsRenderer
          .tabbedRenderer.watchNextTabbedResultsRenderer
          .tabs[0].tabRenderer.content
          .musicQueueRenderer.content
          .playlistPanelRenderer.contents |

        # Get the length for range
        length as $total |

        # Create range of indices
        range(0; $total) as $i |

        .[$i] |
        select(.playlistPanelVideoRenderer != null) |
        .playlistPanelVideoRenderer |
        {
          track: ($i + 1),
          album: $album,
          title: .title.runs[0].text,
          artist: .longBylineText.runs[0].text,
          duration: (
            .lengthText.runs[0].text |
            split(":") |
            map(tonumber) |
            .[0] * 60 + .[1] |
            tostring
          ),
          thumbnail: .thumbnail.thumbnails[-1].url,
          source_id: .videoId,
          url: "https://www.youtube.com/watch?v=\(.videoId)"
        } | tojson
      '
    )"
    ;;
  "song")
    response="$(
      yt-dlp \
        -j \
        "https://www.youtube.com/watch?v=$id" |
        jq '{
          id: .id,
          title: .title,
          length: .duration,
          artist: .artist,
          thumbnail: .thumbnail,
          url: "https://www.youtube.com/watch?v='"$id"'"
        }'
    )"
    ;;
  *)
    echo "{ \"error\": \"Unsupported content type: $type\" }" >&2
    return 1
    ;;
  esac

  echo "$response"
}

related() {
  local obj="$1"
  local type
  local id
  local response

  eval "$(jq -r '@sh "
    type=\(.id.type)
    id=\(.id.value)
    tag=\(.args.tag)
  "' <<<"$obj")"

  case "$type" in
  "artist")
    response="$(getPlaylistFromArtist "$id")"
    ;;
  "album")
    response="$(
      getRawJsonPlaylist '{
        "playlistId": "'"$(buildTaggedPlaylistIdFromAlbum "$id" "$tag")"'"
      }' |
      jq -r '{
        playlist_name: "YouTube Music",
        encoding: "UTF-8",
        tracks: [
          .contents.singleColumnMusicWatchNextResultsRenderer.tabbedRenderer.watchNextTabbedResultsRenderer.tabs[0].tabRenderer.content.musicQueueRenderer.content.playlistPanelRenderer.contents[] |
          select(.playlistPanelVideoRenderer != null) | .playlistPanelVideoRenderer | {
            title: .title.runs[0].text,
            artist: .longBylineText.runs[0].text,
            album: (.longBylineText.runs[2].text // "Unknown"),
            duration: ((.lengthText.runs[0].text | split(":") | map(tonumber) | .[0] * 60 + .[1]) | tostring),
            year: (.longBylineText.runs[4].text // "Unknown"),
            genre: "Unknown",
            thumbnail: .thumbnail.thumbnails[-1].url,
            video_id: .videoId,
            url: "https://www.youtube.com/watch?v=\(.videoId)"
          }
        ]
      }'
    )"
    ;;
  "song")
    response="$(
      getRawJsonPlaylist '{
          "videoId": "'"$videoId"'",
          "playlistId": "'"$(buildTaggedPlaylistIdFromSong "$videoId" "$tag")"'"
      }' |
      jq -r '{
        playlist_name: "YouTube Music",
        encoding: "UTF-8",
        tracks: [
          .contents.singleColumnMusicWatchNextResultsRenderer.tabbedRenderer.watchNextTabbedResultsRenderer.tabs[0].tabRenderer.content.musicQueueRenderer.content.playlistPanelRenderer.contents[] |
          select(.playlistPanelVideoRenderer != null) | .playlistPanelVideoRenderer | {
            title: .title.runs[0].text,
            artist: .longBylineText.runs[0].text,
            album: (.longBylineText.runs[2].text // "Unknown"),
            duration: ((.lengthText.runs[0].text | split(":") | map(tonumber) | .[0] * 60 + .[1]) | tostring),
            year: (.longBylineText.runs[4].text // "Unknown"),
            genre: "Unknown",
            thumbnail: .thumbnail.thumbnails[-1].url,
            video_id: .videoId,
            url: "https://www.youtube.com/watch?v=\(.videoId)"
          }
        ]
      }'
    )"
    ;;
  *)
    echo "{ \"error\": \"Unsupported content type: $type\" }" >&2
    return 1
    ;;
  esac

  echo "$response"
}

execute_command() {
  local input="$1"
  local command
  local response

  # Extract command from input
  command=$(echo "$input" | jq -r '.command')

  # Validate that the command function exists
  if ! declare -F "$command" >/dev/null; then
    echo "{ \"error\": \"Unknown command: $command\" }" >&2
    return 1
  fi

  # Execute the command function
  response=$("$command" "$input")

  # Check if command execution was successful
  if [ $? -ne 0 ]; then
    echo "$response" >&2
    return 1
  fi

  echo "$response"
}

# Main execution flow
main() {
  local json_input
  local id_obj
  local new_input
  local response

  # Read JSON input
  json_input=$(cat)

  # Get and validate the ID
  original_id=$(echo "$json_input" | jq -r '.id')
  id_obj=$(evolve_id "$original_id")

  # If evolve_id failed, exit with error
  if [ $? -ne 0 ]; then
    echo "$id_obj" >&2
    exit 1
  fi

  new_input="$(echo "$json_input" | jq --argjson id_obj "$id_obj" '.id = $id_obj')"
  response=$(execute_command "$new_input")

  # Check if command execution was successful
  if [ $? -ne 0 ]; then
    echo "$response" >&2
    exit 1
  fi

  echo "$response"
}

main
